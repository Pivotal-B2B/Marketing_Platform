Telnyx client delegate
You will need to instantiate the client and set the delegate.

// Initialize the client
let telnyxClient = TxClient()

// Register to get SDK events
telnyxClient.delegate = self
Then you will receive the following events:

extension ViewController: TxClientDelegate {

    func onRemoteCallEnded(callId: UUID) {
        // Call has been removed internally.
    }

    func onSocketConnected() {
       // When the client has successfully connected to the Telnyx Backend.
    }

    func onSocketDisconnected() {
       // When the client from the Telnyx backend
    }

    func onClientError(error: Error)  {
        // Something went wrong.
    }

    func onClientReady()  {
       // You can start receiving incoming calls or
       // start making calls once the client was fully initialized.
    }

    func onSessionUpdated(sessionId: String)  {
       // This function will be executed when a sessionId is received.
    }

    func onIncomingCall(call: Call)  {
       // Someone is calling you.
       // This delegate method will be called when the app is in foreground and the Telnyx Client is connected.
    }

    func onPushCall(call: Call) {
       // If you have configured Push Notifications and app is in background or the Telnyx Client is disconnected
       // this delegate method will be called after the push notification is received.
       // Update the current call with the incoming call
       self.currentCall = call 
    }
    

    // You can update your UI from here based on the call states.
    // Check that the callId is the same as your current call.
    func onCallStateUpdated(callState: CallState, callId: UUID) {
      // handle the new call state
      switch (callState) {
      case .CONNECTING:
          break
      case .RINGING:
          break
      case .NEW:
          break
      case .ACTIVE:
          break
      case .DONE(let reason):
          // The DONE state may include a termination reason with details about why the call ended
          if let reason = reason {
              print("Call ended with reason: \(reason.cause ?? "Unknown")")
              print("SIP code: \(reason.sipCode ?? 0), SIP reason: \(reason.sipReason ?? "None")")
          }
          break
      case .HELD:
          break
      case .RECONNECTING(let reason):
          print("Call reconnecting: \(reason.rawValue)")
          break
      case .DROPPED(let reason):
          print("Call dropped: \(reason.rawValue)")
          break
      }
    }
}
Calls
Outboud call
   // Create a client instance
   self.telnyxClient = TxClient()

   // Asign the delegate to get SDK events
   self.telnyxClient?.delegate = self

   // Connect the client (Check TxClient class for more info)
   self.telnyxClient?.connect(....)

   // Create the call and start calling
   self.currentCall = try self.telnyxClient?.newCall(callerName: "Caller name",
                                                     callerNumber: "155531234567",
                                                     // Destination is required and can be a phone number or SIP URI
                                                     destinationNumber: "18004377950",
                                                     callId: UUID.init())
This is a general example: In order to fully support outbound calls you will need to implement CallKit to properly handle audio states. For more information check Audio Session Handling WebRTC + CallKit section.

Inbound call
How to answer an incoming call:

//Init your client
func initTelnyxClient() {
   //
   self.telnyxClient = TxClient()

   // Asign the delegate to get SDK events
   self.telnyxClient?.delegate = self

   // Connect the client (Check TxClient class for more info)
   self.telnyxClient?.connect(....)
}

extension ViewController: TxClientDelegate {
    //....
    func onIncomingCall(call: Call) {
        // We are automatically answering any incoming call as an example, but
        // maybe you want to store a reference of the call, and answer the call after a button press.
        self.myCall = call.answer()
    }
}
This is a general example: In order to fully support inbound calls you will need to implement PushKit + CallKit. For more information check Setting up VoIP push notifications section.

Preferred Audio Codecs
The SDK allows you to configure preferred audio codecs for your WebRTC calls. This feature enables you to prioritize specific codecs based on your application's requirements for audio quality, bandwidth usage, or network conditions.

Getting Supported Codecs
Query the list of audio codecs supported by the device and WebRTC framework:

// Get all supported audio codecs
let supportedCodecs = telnyxClient.getSupportedAudioCodecs()

// Print codec information
for codec in supportedCodecs {
    print("Codec: \(codec.mimeType), Clock Rate: \(codec.clockRate) Hz")
}
Setting Preferred Codecs
For Outbound Calls:

// Define your preferred codecs in order of priority
let preferredCodecs = [
    TxCodecCapability(mimeType: "audio/opus", clockRate: 48000, channels: 2),
    TxCodecCapability(mimeType: "audio/PCMU", clockRate: 8000, channels: 1)
]

// Create a call with preferred codecs
let call = try telnyxClient.newCall(
    callerName: "John Doe",
    callerNumber: "1234567890",
    destinationNumber: "18004377950",
    callId: UUID(),
    preferredCodecs: preferredCodecs  // Pass preferred codecs
)
For Inbound Calls:

func onIncomingCall(call: Call) {
    let preferredCodecs = [
        TxCodecCapability(mimeType: "audio/opus", clockRate: 48000, channels: 2),
        TxCodecCapability(mimeType: "audio/PCMU", clockRate: 8000, channels: 1)
    ]

    // Answer with preferred codecs
    call.answer(preferredCodecs: preferredCodecs)
}
Common Codec Configurations
High Quality Audio (VoIP apps):

let preferredCodecs = [
    TxCodecCapability(mimeType: "audio/opus", clockRate: 48000, channels: 2)
]
Traditional Telephony Compatibility:

let preferredCodecs = [
    TxCodecCapability(mimeType: "audio/PCMU", clockRate: 8000, channels: 1),
    TxCodecCapability(mimeType: "audio/PCMA", clockRate: 8000, channels: 1)
]
Low Bandwidth Optimization:

let preferredCodecs = [
    TxCodecCapability(mimeType: "audio/iLBC", clockRate: 8000),
    TxCodecCapability(mimeType: "audio/PCMU", clockRate: 8000)
]
For detailed documentation on codec selection, configuration options, and best practices, see the Preferred Audio Codecs Guide.

Call Termination Reasons
When a call ends, the SDK provides detailed information about why the call was terminated through the CallTerminationReason structure. This information is available in the DONE state of the call.

CallTerminationReason Structure
The CallTerminationReason structure contains the following fields:

cause: A string describing the general cause of the call termination (e.g., "CALL_REJECTED", "USER_BUSY")
causeCode: A numerical code corresponding to the cause
sipCode: The SIP response code (e.g., 403, 404)
sipReason: The SIP reason phrase (e.g., "Dialed number is not included in whitelisted countries")
Accessing Call Termination Reasons
You can access the termination reason in the onCallStateUpdated delegate method:

func onCallStateUpdated(callState: CallState, callId: UUID) {
    switch callState {
    case .DONE(let reason):
        if let reason = reason {
            // Access termination details
            let cause = reason.cause
            let sipCode = reason.sipCode
            let sipReason = reason.sipReason
            
            // Display or log the information
            print("Call ended: \(cause ?? "Unknown"), SIP: \(sipCode ?? 0) \(sipReason ?? "")")
        }
        break
    // Handle other states...
    }
}
Common Termination Causes
The SDK provides various termination causes, including:

NORMAL_CLEARING: Call ended normally
USER_BUSY: The called party is busy
CALL_REJECTED: The call was rejected
UNALLOCATED_NUMBER: The dialed number is invalid
INCOMPATIBLE_DESTINATION: The destination cannot handle the call type
WebRTC Statistics
The SDK provides WebRTC statistics functionality to assist with troubleshooting and monitoring call quality. This feature is controlled through the debug flag in the TxClient configuration.

Enabling WebRTC Statistics
To enable WebRTC statistics logging:

let txConfig = TxConfig(sipUser: sipUser,
                       password: password,
                       pushDeviceToken: "DEVICE_APNS_TOKEN",
                       debug: true) // Enable WebRTC statistics
Understanding WebRTC Statistics
When debug: true is configured:

WebRTC statistics logs are automatically collected during calls
Logs are sent to the Telnyx portal and are accessible in the Object Storage section
Statistics are linked to the SIP credential used for testing
The logs help the Telnyx support team diagnose issues and optimize call quality
Real-time Call Quality Monitoring
The SDK provides real-time call quality metrics through the onCallQualityChange callback on the Call object. This allows you to monitor call quality in real-time and provide feedback to users.

Using onCallQualityChanged
// When creating a new call set debug to true for CallQualityMetrics
let call = try telnyxClient.newCall(callerName: "Caller name",
                                   callerNumber: "155531234567",
                                   destinationNumber: "18004377950",
                                   callId: UUID.init(),debug:true)
                                   
//When accepting a call
telnyxClient?.answerFromCallkit(answerAction: action,debug:true) or call?.answer(debug:true)

// Set the onCallQualityChange callback
call.onCallQualityChange = { metrics in
    // Handle call quality metrics
    print("Call quality: \(metrics.quality.rawValue)")
    print("MOS score: \(metrics.mos)")
    print("Jitter: \(metrics.jitter * 1000) ms")
    print("Round-trip time: \(metrics.rtt * 1000) ms")
    
    // Update UI based on call quality
    switch metrics.quality {
    case .excellent, .good:
        // Show excellent/good quality indicator
        self.qualityIndicator.backgroundColor = .green
    case .fair:
        // Show fair quality indicator
        self.qualityIndicator.backgroundColor = .yellow
    case .poor, .bad:
        // Show poor/bad quality indicator
        self.qualityIndicator.backgroundColor = .red
        // Optionally show a message to the user
    case .unknown:
        // Quality couldn't be determined
        self.qualityIndicator.backgroundColor = .gray
    }
}
CallQualityMetrics Properties
The CallQualityMetrics object provides the following properties:

Property	Type	Description
jitter	Double	Jitter in seconds (multiply by 1000 for milliseconds)
rtt	Double	Round-trip time in seconds (multiply by 1000 for milliseconds)
mos	Double	Mean Opinion Score (1.0-5.0)
quality	CallQuality	Call quality rating based on MOS
inboundAudio	[String: Any]?	Inbound audio statistics
outboundAudio	[String: Any]?	Outbound audio statistics
remoteInboundAudio	[String: Any]?	Remote inbound audio statistics
remoteOutboundAudio	[String: Any]?	Remote outbound audio statistics
CallQuality Enum
Value	MOS Range	Description
.excellent	MOS > 4.2	Excellent call quality
.good	4.1 ≤ MOS ≤ 4.2	Good call quality
.fair	3.7 ≤ MOS ≤ 4.0	Fair call quality
.poor	3.1 ≤ MOS ≤ 3.6	Poor call quality
.bad	MOS ≤ 3.0	Bad call quality
.unknown	N/A	Unable to calculate quality
Best Practices for Call Quality Monitoring
User Feedback:

Consider showing a visual indicator of call quality to users
For poor quality calls, provide suggestions (e.g., "Try moving to an area with better connectivity")
Logging:

Log quality metrics for later analysis
Track quality trends over time to identify patterns
Adaptive Behavior:

Implement adaptive behaviors based on call quality
For example, suggest switching to audio-only if video quality is poor
Performance Considerations:

The callback is triggered periodically (approximately every 2 seconds)
Important Notes
Log Access:

If you run the app using SIP credential A with debug: true, the WebRTC logs will be available in the Telnyx portal account associated with credential A
Logs are stored in the Object Storage section of your Telnyx portal
Troubleshooting Support: